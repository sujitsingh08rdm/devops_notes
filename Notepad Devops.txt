DEVOPS => devops is the set of practices that combines software developemnt ->  aim to automating and improving the flow of dev -> test -> deployment. So developement + operations.
build faster, depeloyement safer and easy to maintain.

PLAN -> DEVELOP -> BUILD -> TEST -> RELEASE -> DEPLOY -> MONITOR

UNIX => 
  navigation :
    pwd -> present working directory
    ls -> list all the files
    cd -> change directory
    cd Folder -> to go the Folder
    cd .. -> goes directory back
    cd / -> to goto root directory
    ls -l -> to give details of the the files
    ls -a -> to see hidden file
    touch newFile.txt -> to create a file called newFile.txt
    mkdir test -> to create a new folder/directory called test
    rm filename.txt -> to delete a file 
    rm -r foldername -> to delete a folder
    find -name "fewfile.txt" -> to find the file with name "" 
    grep "hello" newFile.txt -> to find a particular text "hello" inside a file

SHELL SCRIPTING =>
  script -> textfile -> series of commands of that the linux shell (bash) will execute.
  nano firstScriptFile.sh -> nano mean to create a shellScript file.
    /bin/bash
    echo "Hello Word"

  now exit to exit press ctrl+O -> enter -> ctrl+X

  chmod +x firstScriptFile.sh -> to make the script file executeable 
  ./firstScriptFile.sh -> to execute this script we will get "Hello Word"

  nano variables.sh 
  /bin/bash
  name = "sangam"
  echo "Hello $name!"

  execute it we will get Hello sangam!

  nano conditionals.sh
  number=5
  if [ $number -gt 5 ]; then 
    echo "The number is greater then 5"
  else
    echo "The numebr is not greater then 5"

  execute it 


GIT => 
git is a version control system that tracks changes in your source code.
github is cloud based hosting service


git branch -> to show branch
git branch "branchname" -> to create a new branch
git switch "branchname" -> to switch a branch
git switch -c "branchname" -> to create a branch and switch it
git branch -d "branchname" -> to delete branch
-now again do chanign a little code and try to publish the dev branch-
git switch dev
git add.
git commit -m "change in dev"
git push -u origin dev
-now to merge the changes to main branch from dev branch we will-
git switch main
git merge dev 
git push
git pull -> to get sync the branch from cloud to local.
git checkout -b feature_one -> creates a new branch feature_one and switches to it immediately


DOCKER => 

docker run -d -p 8080:80 nginx , to create a container , if nginx is nout found locally it will download, -d to run in detach mode(background), -p port (client:docker) 
docker ps -> show all the running containers
docker ps -a -> -a list all containers
docker stop <containerId> -> stop a running container
docker rm <containerId> -> to delete a container from docker (container should be in stop state)
docker prune -> to stop all the running docker containers
docker rmi <imagename> -> to remove an image
docker rmi -f <imagename> -> to remove an image by force
docker build -t mern-backend . -> -t tags the image that we can reference later
docker run -p 5000:5000 --name customName mern-backend ->  
docker run -p 5000:5000 --name customName --env-file.env mern-backend -> read the env filecontent 

same for frotnend

DOCKER COMPOSE => 

its a tool to comfig a multi-container app in a single-yaml
 
docker-compose up --build -d -> to run docker
docker-compose down -> to bring down everything 
docker-compose logs -> to view logs


CI =>

create a .github folder then workflows then a ci.yml file then add below code in it.

name: build-and-lint

# triggers :define when this workflow should run
# trigger on push to these branches

on:
  push:
    branches: [main, dev]
  pull_request:
    branches: [main, dev]

#define a job or multiple jobs

jobs:
  build-and-lint:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Setup node
        uses: actions/setup-node@v3
        with:
          node-version: 20

      - name: Install backend depedencies
        working-directory: server
        run: npm ci

      - name: Lint backend
        working-directory: server
        run: npm run lint -- --max-warnings=0

      - name: Install frontend depedencies
        working-directory: client
        run: npm ci

      - name: Lint frontend
        working-directory: client
        run: npm run lint -- --max-warnings=35

      - name: Build backend image
        run: docker build -t backend ./server

      - name: Build frontend image
        run: docker build -t frontend ./client

Now make changes and push the branch to github. Now we should see it. in actions.

CD =>

Now lets come to deployement using EC2 (change the network tab is the needed port 5000 and 5173 using tcp connection and then also create a keypair). create a instatace now loging to instance using 
ssh -i "C:\Users\sujit\.ssh\keypair.pem" ec2-user@13.60.210.125

install docker -> nano install_docker_amazon.sh 
inside sh

--------------------------------------------------------------------------------------------------
#! /bin/bash

echo "Updating system packages..."
sudo dnf update -y

echo "Installing Docker..."
sudo dnf install -y docker

echo "Adding ec2-user to docker group..."
sudo usermod -aG docker ec2-user

echo "Enabling and starting docker services..."
sudo systemctl enable docker
sudo systemctl start docker

echo "Verifying docker installation..."
docker --version || echo "DOcker not found in current sessions (re-login may be required)."

echo ""
echo "docker installations complete on Amazon linux 2023!"
echo "IMPORTANT : Logout and log back in (or run 'newgrpdocker')"
echo "so that 'ec2-user' can run docker without sudo."
echo ""
echo "After re-login, test with:"
echo "docker run hello-world"

--------------------------------------------------------------------------------------------------

now make that script executeable 
chmod +x install_docker_amazon.sh
./install_docker_amazon.sh to execute it
then exit then connect again
docker --version to verify docker version
now we have to install docker compose before that we have to make a directory
sudo mkdir -p /usr/local/lib/docker/cli-plugins
then 
sudo curl -SL https://github.com/docker/compose/releases/download/v2.29.2/docker-compose-linux-x86_64 -o /usr/local/lib/docker/cli-plugins/docker-compose
then make the file executeable 
sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
docker compose version -> to verify docker compose isntalled or not 

Now install git 
sudo dnf install -y git

Now we have to clone our repo-
git clone https://github.com/sujitsingh08rdm/devops-ecommerce-practice.git app
then nano server/.env then paste everything from your server env to this file and save
same for client side
now lets createa docker ignore file to exclude the files that are not needed in docker
inside htat ignore file add below for both client and server in client coverage wont be there

node_modules
npm-debug.log
Dockerfile
.dockerignore
.git
.gitignore
.env
coverage
dist

chnage the preview in client to 
"preview": "vite preview --host 0.0.0.0 --port 5173",

add these two line in docker file 
ARG VITE_API_URL
ENV VITE_API_URL=$VITE_API_URL

now update hte docker-compose file so taht it could pick the values from that arg
this should be on docker-compose for client

-----------------------------------------------------------------
  frontend:
    build:
      context: ./client
      args: 
        VITE_API_URL: http:/3.36.2422.54:5000/api
      container_name: frontend01
      restart: always
      ports:
        - "5173:5173"
      depends_on:
        - backend

-----------------------------------------------------------------

then commit that to main branch and pull in our aws server using git pull
for testing just press git branch 
then git pull
docker compose build -> it will start the build process
docker compose up -d
docker compose ps to view all the running instances
docker compose logs to view logs 

deployed sucessfully

CD =>

